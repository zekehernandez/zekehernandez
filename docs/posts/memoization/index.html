<!doctype html> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=fonts.css rel=stylesheet> <link href=highlight.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.png rel=icon type=image/png> <link href=client/main.3576138779.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Memoization in the wild</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <div class="svelte-v25qrq layout"><header class=svelte-y9ah38><nav class=svelte-13jg14k><a href=. class=svelte-13jg14k>Home</a> <a href=about class=svelte-13jg14k>About</a> <a href=posts class="svelte-13jg14k selected" rel=prefetch>Posts</a></nav></header> <main class=svelte-v25qrq> <header class=svelte-1nln9ed><p class=svelte-1nln9ed>June 7, 2017 ~ 3 min read</p> <h1 class=svelte-1nln9ed>Memoization in the wild</h1></header> <div class=container><article class=content><h3 id=time-weighted-returns>Time-weighted returns</h3> <p>Let's consider a portfolio's <a href=http://www.investopedia.com/terms/t/time-weightedror.asp target=_blank rel=nofollow>time-weighted return</a>, or TWR. </p> <p>Each day the value of a portfolio can either rise or drop a certain percentage. Now, let's say you have a list of the daily returns since the inception of the portfolio and you want to find out what the portfolio's returns over several date-ranges are. Most likely you'll want to know the daily return, the week-to-date return, month-to-date return, and so on, up to the inception-to-date return.</p> <p>To calculate the time-weighted return from inception to a certain end-date, one would need to do the following:</p> <p>R<sub>twr</sub> = ((1+R<sub>1</sub>) x ... x (1+R<sub>n</sub>)) - 1</p> <p>where R<sub>1</sub> is the daily return after the inception date, and R<sub>n </sub> is end-date's daily return. So we have to iterate over this list of daily returns multiple times in order to calculate all our returns, right? No. You see, the above formula doesn't just work for daily returns, but rather returns over any arbitrary, consecutive periods. So if you have a return for the month of April and one for the month of May, you could do the following:</p> <p>R<sub>twr</sub> = ((1+R<sub>apr</sub>) x (1+R<sub>may</sub>)) - 1 </p> <p>and you would end up with the return over both months. You see where I'm going with this? </p> <h3 id=devising-our-plan>Devising our plan</h3> <p>First things first, we need to get our dates straight. We need our end-date that we are getting returns for, we need the inception date, the last day of the previous year/quarter/month/week (in regards to the end-date), and the day before the end-date. We'll call these dates our breakpoints. </p> <p>Okay, so we will store our daily returns in an array, sorted by date, ascending. We will translate our date breakpoints into indexes into that array by subtracting the inception date from those dates. </p> <p>We'll have a function <code>GetReturnOverDates(startDate, endDate)</code> that calculates the total return from <code>startDate</code> to <code>endDate</code>. Now this is where the memoization comes in. The first thing <code>GetReturnOverDates</code> does is check a map to see if this date range has already had a return calculated for it; if it does, it returns that. It then iterates from <code>startDate</code> to <code>endDate</code>, adding each daily return to the formula at the top. Once we iterate to a breakpoint, we then call <code>GetReturnOverDates(breakpoint, endDate)</code> and add that to our formula. Essentially making the formula:</p> <p>R<sub>twr</sub> = ((1+R<sub>startDate</sub>) x ... x (1+R<sub>breakpoint</sub>) x R<sub>trw2</sub>) - 1</p> <p>where R<sub>twr2</sub> is the result of <code>GetReturnOverDates(breakpoint, endDate)</code>.</p> <h3 id=the-payoff>The payoff</h3> <p>So, lets say we already calculated the daily and week-to-date return and we want to get the month-to-date return. We start by calling <code>GetReturnOverDates</code>. It will iterate from the last day of the previous month until it hits a breakpoint, which will most likely be the last day of the previous week (if we aren't in the first week of the month). It will then call <code>GetReturnOverDates(breakpoint, endDate)</code> and that call will find that we already calculated that return and won't have to do any more calculations! We then keep doing this for quarter-to-date, year-to-date, and finally, inception-to-date, all without iterating over the same daily return more than once!</p> <h3 id=closing-thoughts>Closing thoughts</h3> <p>It should be noted that if the inception date is more than a year prior to the end-date, its return is probably most useful if it is annualized. This doesn't really change our method above, it just tacks on an extra calculation at the end.</p> </article></div></main> <footer class=svelte-v25qrq><span>Â© 2020 Zeke Hernandez. Powered by <a href=https://sapper.svelte.dev target=_blank>Sapper</a>. Template by <a href=https://www.twitter.com/Charca target=_blank>Maxi Ferreira</a>. </span></footer></div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"Memoization in the wild",slug:"memoization",html:"\u003Ch3 id=\"time-weighted-returns\"\u003ETime-weighted returns\u003C\u002Fh3\u003E\n\u003Cp\u003ELet&#39;s consider a portfolio&#39;s \u003Ca target=\"_blank\" rel=\"nofollow\" href=\"http:\u002F\u002Fwww.investopedia.com\u002Fterms\u002Ft\u002Ftime-weightedror.asp\"\u003Etime-weighted return\u003C\u002Fa\u003E, or TWR. \u003C\u002Fp\u003E\n\u003Cp\u003EEach day the value of a portfolio can either rise or drop a certain percentage. Now, \nlet&#39;s say you have a list of the daily returns since the inception of the \nportfolio and you want to find out what the portfolio&#39;s returns over several \ndate-ranges are. Most likely you&#39;ll want to know the daily return, the \nweek-to-date return, month-to-date return, and so on, up to the \ninception-to-date return.\u003C\u002Fp\u003E\n\u003Cp\u003ETo calculate the time-weighted return from inception to a certain end-date, \none would need to do the following:\u003C\u002Fp\u003E\n\u003Cp\u003ER\u003Csub\u003Etwr\u003C\u002Fsub\u003E = ((1+R\u003Csub\u003E1\u003C\u002Fsub\u003E) x ... x (1+R\u003Csub\u003En\u003C\u002Fsub\u003E)) - 1\u003C\u002Fp\u003E\n\u003Cp\u003Ewhere R\u003Csub\u003E1\u003C\u002Fsub\u003E is the daily return after the inception date, and R\u003Csub\u003En\n\u003C\u002Fsub\u003E is end-date&#39;s daily return. So we have to iterate over this list of daily \nreturns multiple times in order to calculate all our returns, right? \nNo. You see, the above formula doesn&#39;t just work for daily returns, but rather \nreturns over any arbitrary, consecutive periods. So if you have a return for the \nmonth of  April and one for the month of May, you could do the following:\u003C\u002Fp\u003E\n\u003Cp\u003ER\u003Csub\u003Etwr\u003C\u002Fsub\u003E = ((1+R\u003Csub\u003Eapr\u003C\u002Fsub\u003E) x (1+R\u003Csub\u003Emay\u003C\u002Fsub\u003E)) - 1 \u003C\u002Fp\u003E\n\u003Cp\u003Eand you would end up with the return over both months. You see where I&#39;m going \nwith this? \u003C\u002Fp\u003E\n\u003Ch3 id=\"devising-our-plan\"\u003EDevising our plan\u003C\u002Fh3\u003E\n\u003Cp\u003EFirst things first, we need to get our dates straight. We need our end-date that\nwe are getting returns for, we need the inception date, the last day of the\nprevious year\u002Fquarter\u002Fmonth\u002Fweek (in regards to the end-date), and the day \nbefore the end-date. We&#39;ll call these dates our breakpoints. \u003C\u002Fp\u003E\n\u003Cp\u003EOkay, so we will store our daily returns in an array, sorted by date, ascending.\nWe will translate our date breakpoints into indexes into that array by \nsubtracting the inception date from those dates. \u003C\u002Fp\u003E\n\u003Cp\u003EWe&#39;ll have a function \u003Ccode\u003EGetReturnOverDates(startDate, endDate)\u003C\u002Fcode\u003E that calculates \nthe total return from \u003Ccode\u003EstartDate\u003C\u002Fcode\u003E to \u003Ccode\u003EendDate\u003C\u002Fcode\u003E. Now this is where the \nmemoization comes in. The first thing \u003Ccode\u003EGetReturnOverDates\u003C\u002Fcode\u003E does is check a map \nto see if this date range has already had a return calculated for it; if it \ndoes, it returns that. It then iterates from \u003Ccode\u003EstartDate\u003C\u002Fcode\u003E to \u003Ccode\u003EendDate\u003C\u002Fcode\u003E, adding \neach daily return to the formula at the top. Once we iterate to a breakpoint, \nwe then call \u003Ccode\u003EGetReturnOverDates(breakpoint, endDate)\u003C\u002Fcode\u003E and add that to our \nformula. Essentially making the formula:\u003C\u002Fp\u003E\n\u003Cp\u003ER\u003Csub\u003Etwr\u003C\u002Fsub\u003E = ((1+R\u003Csub\u003EstartDate\u003C\u002Fsub\u003E) x ... x (1+R\u003Csub\u003Ebreakpoint\u003C\u002Fsub\u003E) \nx R\u003Csub\u003Etrw2\u003C\u002Fsub\u003E) - 1\u003C\u002Fp\u003E\n\u003Cp\u003Ewhere R\u003Csub\u003Etwr2\u003C\u002Fsub\u003E is the result of \n\u003Ccode\u003EGetReturnOverDates(breakpoint, endDate)\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"the-payoff\"\u003EThe payoff\u003C\u002Fh3\u003E\n\u003Cp\u003ESo, lets say we already calculated the daily and week-to-date return and we want \nto  get the month-to-date return. We start by calling \u003Ccode\u003EGetReturnOverDates\u003C\u002Fcode\u003E. It \nwill iterate from the last day of the previous month until it hits a breakpoint, \nwhich will most likely be the last day of the previous week (if we aren&#39;t in \nthe first week of the month). It will then call \n\u003Ccode\u003EGetReturnOverDates(breakpoint, endDate)\u003C\u002Fcode\u003E and that call will find that we \nalready calculated that return and won&#39;t have to do any more calculations! We \nthen keep doing this for quarter-to-date, year-to-date, and finally,\ninception-to-date, all without iterating over the same daily return more than \nonce!\u003C\u002Fp\u003E\n\u003Ch3 id=\"closing-thoughts\"\u003EClosing thoughts\u003C\u002Fh3\u003E\n\u003Cp\u003EIt should be noted that if the inception date is more than a year prior to the\nend-date, its return is probably most useful if it is annualized. This doesn&#39;t\nreally change our method above, it just tacks on an extra calculation at the \nend.\u003C\u002Fp\u003E\n",date:"2017-06-07T23:18:32.000Z",excerpt:"\nMemoization isn't just for fibonacci numbers.\n\n",printDate:"June 7, 2017",printReadingTime:"3 min read"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.d0671e41.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.d0671e41.js")}document.head.appendChild(s)</script> 