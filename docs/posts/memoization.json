{"title":"Memoization in the wild","slug":"memoization","html":"<h3 id=\"time-weighted-returns\">Time-weighted returns</h3>\n<p>Let&#39;s consider a portfolio&#39;s <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.investopedia.com/terms/t/time-weightedror.asp\">time-weighted return</a>, or TWR. </p>\n<p>Each day the value of a portfolio can either rise or drop a certain percentage. Now, \nlet&#39;s say you have a list of the daily returns since the inception of the \nportfolio and you want to find out what the portfolio&#39;s returns over several \ndate-ranges are. Most likely you&#39;ll want to know the daily return, the \nweek-to-date return, month-to-date return, and so on, up to the \ninception-to-date return.</p>\n<p>To calculate the time-weighted return from inception to a certain end-date, \none would need to do the following:</p>\n<p>R<sub>twr</sub> = ((1+R<sub>1</sub>) x ... x (1+R<sub>n</sub>)) - 1</p>\n<p>where R<sub>1</sub> is the daily return after the inception date, and R<sub>n\n</sub> is end-date&#39;s daily return. So we have to iterate over this list of daily \nreturns multiple times in order to calculate all our returns, right? \nNo. You see, the above formula doesn&#39;t just work for daily returns, but rather \nreturns over any arbitrary, consecutive periods. So if you have a return for the \nmonth of  April and one for the month of May, you could do the following:</p>\n<p>R<sub>twr</sub> = ((1+R<sub>apr</sub>) x (1+R<sub>may</sub>)) - 1 </p>\n<p>and you would end up with the return over both months. You see where I&#39;m going \nwith this? </p>\n<h3 id=\"devising-our-plan\">Devising our plan</h3>\n<p>First things first, we need to get our dates straight. We need our end-date that\nwe are getting returns for, we need the inception date, the last day of the\nprevious year/quarter/month/week (in regards to the end-date), and the day \nbefore the end-date. We&#39;ll call these dates our breakpoints. </p>\n<p>Okay, so we will store our daily returns in an array, sorted by date, ascending.\nWe will translate our date breakpoints into indexes into that array by \nsubtracting the inception date from those dates. </p>\n<p>We&#39;ll have a function <code>GetReturnOverDates(startDate, endDate)</code> that calculates \nthe total return from <code>startDate</code> to <code>endDate</code>. Now this is where the \nmemoization comes in. The first thing <code>GetReturnOverDates</code> does is check a map \nto see if this date range has already had a return calculated for it; if it \ndoes, it returns that. It then iterates from <code>startDate</code> to <code>endDate</code>, adding \neach daily return to the formula at the top. Once we iterate to a breakpoint, \nwe then call <code>GetReturnOverDates(breakpoint, endDate)</code> and add that to our \nformula. Essentially making the formula:</p>\n<p>R<sub>twr</sub> = ((1+R<sub>startDate</sub>) x ... x (1+R<sub>breakpoint</sub>) \nx R<sub>trw2</sub>) - 1</p>\n<p>where R<sub>twr2</sub> is the result of \n<code>GetReturnOverDates(breakpoint, endDate)</code>.</p>\n<h3 id=\"the-payoff\">The payoff</h3>\n<p>So, lets say we already calculated the daily and week-to-date return and we want \nto  get the month-to-date return. We start by calling <code>GetReturnOverDates</code>. It \nwill iterate from the last day of the previous month until it hits a breakpoint, \nwhich will most likely be the last day of the previous week (if we aren&#39;t in \nthe first week of the month). It will then call \n<code>GetReturnOverDates(breakpoint, endDate)</code> and that call will find that we \nalready calculated that return and won&#39;t have to do any more calculations! We \nthen keep doing this for quarter-to-date, year-to-date, and finally,\ninception-to-date, all without iterating over the same daily return more than \nonce!</p>\n<h3 id=\"closing-thoughts\">Closing thoughts</h3>\n<p>It should be noted that if the inception date is more than a year prior to the\nend-date, its return is probably most useful if it is annualized. This doesn&#39;t\nreally change our method above, it just tacks on an extra calculation at the \nend.</p>\n","date":"2017-06-07T23:18:32.000Z","excerpt":"\nMemoization isn't just for fibonacci numbers.\n\n","printDate":"June 7, 2017","printReadingTime":"3 min read"}